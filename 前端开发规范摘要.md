# Vue 前端开发规范摘要

## 🎯 规范目标

建立现代化、统一的Vue 3 + TypeScript前端开发标准，提升团队协作效率和代码质量。

---

## 1. TypeScript 开发规范 🔷

### 📝 组件类型定义

```typescript
// 定义Props接口
interface UserCardProps {
  user: User
  showAvatar?: boolean
  size?: 'sm' | 'md' | 'lg'
  disabled?: boolean
}

// 定义Emits接口  
interface UserCardEmits {
  'user-click': [user: User]
  'status-change': [status: boolean]
}

// 组件中使用
const props = withDefaults(defineProps<UserCardProps>(), {
  showAvatar: true,
  size: 'md',
  disabled: false
})

const emit = defineEmits<UserCardEmits>()
```

### 🛡️ 类型安全实践

```typescript
// 业务类型定义
interface User {
  id: string
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
  createdAt: Date
  profile?: UserProfile
}

// API响应类型
interface ApiResponse<T> {
  code: number
  message: string
  data: T
  timestamp: number
}

// 工具类型应用
type UserKeys = keyof User
type PartialUser = Partial<User>
type RequiredUser = Required<User>
```

### 🚀 Vue特殊应用场景

#### 🎭 模板引用类型化
```typescript
<template>
  <input ref="inputRef" type="text" />
  <MyComponent ref="componentRef" />
</template>

<script setup lang="ts">
import { ref, onMounted, useTemplateRef } from 'vue'
import MyComponent from './MyComponent.vue'

// 方法一：传统ref方式（需要显式null类型）
const inputRef = ref<HTMLInputElement | null>(null)
const componentRef = ref<InstanceType<typeof MyComponent> | null>(null)

// 方法二：Vue 3.5+ 推荐的useTemplateRef方式
const inputRefNew = useTemplateRef<HTMLInputElement>('inputRef')
const componentRefNew = useTemplateRef<InstanceType<typeof MyComponent>>('componentRef')

onMounted(() => {
  inputRefNew.value?.focus()
  componentRefNew.value?.someMethod()
})
</script>
```

**推荐使用 `useTemplateRef`**：
- 更好的类型推导
- 自动处理null安全
- 更清晰的语义

```typescript
// useTemplateRef高级用法
<template>
  <div ref="containerRef" class="container">
    <input 
      v-for="(item, index) in items" 
      :key="item.id"
      :ref="(el) => setItemRef(el, index)"
      type="text" 
    />
  </div>
</template>

<script setup lang="ts">
import { ref, useTemplateRef, onMounted } from 'vue'

// 单个元素引用
const containerRef = useTemplateRef<HTMLDivElement>('containerRef')

// 多个元素引用（动态ref）
const itemRefs = ref<HTMLInputElement[]>([])

const setItemRef = (el: HTMLInputElement | null, index: number) => {
  if (el) {
    itemRefs.value[index] = el
  }
}

// 条件渲染的ref
const conditionalRef = useTemplateRef<HTMLElement>('conditionalElement')

onMounted(() => {
  // 安全访问容器
  if (containerRef.value) {
    containerRef.value.scrollIntoView()
  }
  
  // 批量操作输入框
  itemRefs.value.forEach(input => {
    input.addEventListener('focus', handleInputFocus)
  })
})
</script>
```

#### 🔄 响应式数据类型推导
```typescript
// 基础类型自动推导
const count = ref(0) // Ref<number>
const message = ref('hello') // Ref<string>
const isLoading = ref(false) // Ref<boolean>

// 复杂类型需要显式指定
const user = ref<User | null>(null) // 推荐：明确null类型
const users = ref<User[]>([]) // 空数组需要指定类型
const apiData = ref<ApiResponse<any> | undefined>() // 可能未定义的数据

// 复杂响应式数据
const formData = reactive({
  name: '',
  age: 0,
  email: '',
  preferences: {
    theme: 'light' as 'light' | 'dark', // 联合类型
    notifications: true,
    language: 'zh-CN' as const // 字面量类型
  }
})

// 可选链与空值合并
const userDisplayName = computed(() => {
  return user.value 
    ? `${user.value.firstName ?? ''} ${user.value.lastName ?? ''}`.trim()
    : '未登录'
}) // ComputedRef<string>

// 类型守卫在计算属性中的应用
const activeUser = computed(() => {
  return user.value?.isActive ? user.value : null
}) // ComputedRef<User | null>
```

#### 🎪 provide/inject 类型化
```typescript
// 定义注入键和类型
import { InjectionKey, Ref } from 'vue'

interface UserContext {
  user: Ref<User | null>
  login: (credentials: LoginData) => Promise<void>
  logout: () => void
}

// 创建类型化的注入键
export const userContextKey: InjectionKey<UserContext> = Symbol('userContext')

// 父组件提供
<script setup lang="ts">
import { provide, ref } from 'vue'

const user = ref<User | null>(null)

const login = async (credentials: LoginData) => {
  // 登录逻辑
}

const logout = () => {
  user.value = null
}

provide(userContextKey, {
  user,
  login,
  logout
})
</script>

// 子组件注入
<script setup lang="ts">
import { inject } from 'vue'

const userContext = inject(userContextKey)
if (!userContext) {
  throw new Error('UserContext not provided')
}

// 类型安全的使用
userContext.login({ email: '', password: '' })
</script>
```

#### 🔧 自定义指令类型化
```typescript
// 定义指令类型
import { Directive, DirectiveBinding } from 'vue'

interface ClickOutsideElement extends HTMLElement {
  __clickOutsideHandler__?: (event: Event) => void
}

// 类型化的自定义指令
const vClickOutside: Directive<ClickOutsideElement, () => void> = {
  mounted(el, binding) {
    const handler = (event: Event) => {
      if (!el.contains(event.target as Node)) {
        binding.value()
      }
    }
    
    el.__clickOutsideHandler__ = handler
    document.addEventListener('click', handler)
  },
  
  unmounted(el) {
    if (el.__clickOutsideHandler__) {
      document.removeEventListener('click', el.__clickOutsideHandler__)
      delete el.__clickOutsideHandler__
    }
  }
}

// 使用
<div v-click-outside="handleClickOutside">
  点击外部关闭
</div>
```

#### 🎯 事件处理类型化
```typescript
<template>
  <form @submit="handleSubmit">
    <input 
      @input="handleInput"
      @keydown="handleKeydown"
      @focus="handleFocus"
    />
    <button @click="handleClick">提交</button>
  </form>
</template>

<script setup lang="ts">
// 明确的事件类型
const handleSubmit = (event: Event) => {
  event.preventDefault()
  const form = event.target as HTMLFormElement
  const formData = new FormData(form)
}

const handleInput = (event: Event) => {
  const target = event.target as HTMLInputElement
  console.log('输入值:', target.value)
}

const handleKeydown = (event: KeyboardEvent) => {
  if (event.key === 'Enter') {
    event.preventDefault()
    // 处理回车
  }
}

const handleFocus = (event: FocusEvent) => {
  const target = event.target as HTMLInputElement
  target.select()
}

const handleClick = (event: MouseEvent) => {
  // 获取点击坐标
  console.log(`点击位置: (${event.clientX}, ${event.clientY})`)
}
</script>
```

#### 🔮 Watch类型化
```typescript
<script setup lang="ts">
import { ref, watch, watchEffect } from 'vue'

const user = ref<User | null>(null)
const searchQuery = ref('')
const filters = reactive({
  category: '',
  status: 'active' as 'active' | 'inactive'
})

// 单一源监听
watch(user, (newUser, oldUser) => {
  // newUser 和 oldUser 都是 User | null 类型
  if (newUser) {
    console.log('用户登录:', newUser.name)
  }
})

// 多源监听
watch([searchQuery, filters], ([newQuery, newFilters], [oldQuery, oldFilters]) => {
  // 参数类型自动推导
  console.log('搜索条件变化:', newQuery, newFilters)
})

// getter 监听
watch(
  () => user.value?.status,
  (newStatus) => {
    // newStatus 类型为 string | undefined
    if (newStatus) {
      console.log('用户状态变更:', newStatus)
    }
  }
)

// watchEffect 副作用
watchEffect(() => {
  // 自动追踪依赖
  if (user.value && searchQuery.value) {
    console.log(`${user.value.name} 搜索: ${searchQuery.value}`)
  }
})
</script>
```

#### 🎨 CSS Modules 类型化
```typescript
// styles.module.css
.container {
  padding: 20px;
}

.title {
  font-size: 24px;
}

// 组件中使用
<template>
  <div :class="styles.container">
    <h1 :class="styles.title">{{ title }}</h1>
  </div>
</template>

<script setup lang="ts">
// 类型化CSS Modules
import styles from './styles.module.css'

// styles 类型为 Record<string, string>
// 支持智能提示和类型检查

interface Props {
  title: string
}

defineProps<Props>()
</script>
```

#### 🌟 高级类型应用

##### 🔧 泛型组件
```typescript
// GenericTable.vue - 泛型表格组件
<template>
  <table class="generic-table">
    <thead>
      <tr>
        <th v-for="column in columns" :key="column.key">
          {{ column.title }}
        </th>
      </tr>
    </thead>
    <tbody>
      <tr v-for="item in data" :key="getRowKey(item)">
        <td v-for="column in columns" :key="column.key">
          <slot 
            :name="column.key" 
            :item="item" 
            :value="item[column.key]"
          >
            {{ item[column.key] }}
          </slot>
        </td>
      </tr>
    </tbody>
  </table>
</template>

<script setup lang="ts" generic="T extends Record<string, any>">
interface Column<K extends keyof T> {
  key: K
  title: string
  sortable?: boolean
}

interface Props<T> {
  data: T[]
  columns: Column<keyof T>[]
  rowKey?: keyof T | ((item: T) => string | number)
}

const props = defineProps<Props<T>>()

const getRowKey = (item: T): string | number => {
  if (typeof props.rowKey === 'function') {
    return props.rowKey(item)
  }
  return props.rowKey ? String(item[props.rowKey]) : String(item.id || Math.random())
}
</script>

// 使用泛型组件
<GenericTable 
  :data="users"
  :columns="userColumns" 
  row-key="id"
>
  <template #actions="{ item }">
    <button @click="editUser(item)">编辑</button>
  </template>
</GenericTable>
```

##### 🎪 条件类型与映射类型
```typescript
// 条件类型：根据属性类型生成表单组件
type FormFieldComponent<T> = T extends string
  ? 'input'
  : T extends number
  ? 'number-input'
  : T extends boolean
  ? 'checkbox'
  : T extends Date
  ? 'date-picker'
  : 'input'

// 映射类型：自动生成表单配置
type FormConfig<T> = {
  [K in keyof T]: {
    component: FormFieldComponent<T[K]>
    label: string
    required?: boolean
    placeholder?: string
  }
}

// 实际应用
interface UserForm {
  name: string
  age: number
  isActive: boolean
  birthDate: Date
}

const formConfig: FormConfig<UserForm> = {
  name: {
    component: 'input', // 自动推导为 'input'
    label: '姓名',
    required: true
  },
  age: {
    component: 'number-input', // 自动推导为 'number-input'
    label: '年龄'
  },
  isActive: {
    component: 'checkbox', // 自动推导为 'checkbox'
    label: '是否激活'
  },
  birthDate: {
    component: 'date-picker', // 自动推导为 'date-picker'
    label: '出生日期'
  }
}
```

##### 🔍 类型守卫与断言
```typescript
// 类型守卫函数
function isUser(obj: any): obj is User {
  return obj && 
         typeof obj.id === 'string' &&
         typeof obj.name === 'string' &&
         typeof obj.email === 'string'
}

// 联合类型守卫
function isSuccessResponse<T>(
  response: ApiResponse<T> | ErrorResponse
): response is ApiResponse<T> {
  return response.code === 200
}

// 在组件中使用
<script setup lang="ts">
const handleApiResponse = (response: ApiResponse<User> | ErrorResponse) => {
  if (isSuccessResponse(response)) {
    // TypeScript 知道这里 response 是 ApiResponse<User>
    console.log('用户数据:', response.data)
  } else {
    // TypeScript 知道这里 response 是 ErrorResponse
    console.error('错误信息:', response.error)
  }
}

const processUnknownData = (data: unknown) => {
  if (isUser(data)) {
    // TypeScript 知道这里 data 是 User 类型
    console.log('用户名:', data.name)
  }
}
</script>
```

##### 🎨 模板字面量类型
```typescript
// 事件名称类型安全
type EventPrefix = 'on'
type UserEvents = 'click' | 'hover' | 'focus'
type UserEventHandlers = `${EventPrefix}${Capitalize<UserEvents>}`
// 结果: 'onClick' | 'onHover' | 'onFocus'

// 路由路径类型
type RouteModule = 'user' | 'product' | 'order'
type RouteAction = 'list' | 'detail' | 'edit' | 'create'
type RoutePath = `/${RouteModule}/${RouteAction}`
// 结果: '/user/list' | '/user/detail' | ... 

// 组件中使用
interface ComponentProps {
  onClick?: () => void
  onHover?: () => void
  onFocus?: () => void
}

const router = useRouter()
const navigateTo = (path: RoutePath) => {
  router.push(path) // 类型安全的路由导航
}
```

##### 🔗 递归类型与树形结构
```typescript
// 递归树形数据类型
interface TreeNode<T = any> {
  id: string
  data: T
  children?: TreeNode<T>[]
  parent?: TreeNode<T>
}

// 菜单树类型
interface MenuItem {
  name: string
  icon?: string
  path?: string
  permission?: string
}

type MenuTree = TreeNode<MenuItem>

// 树形组件
<script setup lang="ts" generic="T">
interface Props {
  tree: TreeNode<T>[]
  showChildren?: boolean
}

const props = defineProps<Props>()

const renderNode = (node: TreeNode<T>) => {
  // 递归渲染树节点
}
</script>
```

### 🎯 核心原则

- **接口优先**: 复杂类型使用interface定义
- **严格模式**: 启用TypeScript严格检查
- **类型推导**: 合理利用类型推导减少冗余
- **泛型应用**: 提高代码复用性
- **Vue集成**: 充分利用Vue 3的TypeScript支持

---

## 2. 命名规范标准 📝

### 🎯 组件命名规范

#### Vue组件命名
```typescript
// ✅ 正确：PascalCase，多单词组合
UserProfile.vue
ProductCard.vue
NavigationMenu.vue
ShoppingCartItem.vue

// ❌ 错误：单个单词或非PascalCase
user.vue
productcard.vue
navigation-menu.vue
shopping_cart_item.vue
```

#### 组件实例命名
```vue
<template>
  <!-- ✅ 正确：PascalCase -->
  <UserProfile :user="currentUser" />
  <ProductCard v-for="product in products" :key="product.id" />
  
  <!-- ❌ 错误：kebab-case或其他格式 -->
  <user-profile :user="currentUser" />
  <product_card v-for="product in products" :key="product.id" />
</template>
```

### 📁 文件和目录命名规范

#### 目录结构命名
```bash
# ✅ 正确：kebab-case
src/
├── components/
│   ├── base/           # 基础组件
│   ├── common/         # 通用组件
│   └── page-specific/  # 页面特定组件
├── views/
│   ├── user-management/
│   └── product-catalog/
├── utils/
│   ├── api-helpers/
│   └── date-formatters/
└── stores/
    ├── user-store/
    └── product-store/

# ❌ 错误：混合命名方式
src/
├── Components/         # 首字母大写
├── pageSpecific/       # camelCase
├── api_helpers/        # snake_case
└── UserStore/          # PascalCase目录
```

#### 文件命名规范
```bash
# ✅ Vue组件：PascalCase
UserProfile.vue
ProductCard.vue
NavigationHeader.vue

# ✅ TypeScript文件：kebab-case
user-service.ts
api-client.ts
date-utils.ts

# ✅ 样式文件：kebab-case
main-layout.scss
user-card.module.css
global-variables.css

# ✅ 配置文件：kebab-case
vite.config.ts
eslint.config.js
tailwind.config.js
```

### 🔤 变量和函数命名规范

#### JavaScript/TypeScript命名
```typescript
// ✅ 变量和函数：camelCase
const userName = 'john'
const isAuthenticated = true
const userProfile = { name: 'John', age: 30 }

function getUserData() { }
function validateUserInput() { }
function handleButtonClick() { }

// ✅ 常量：SCREAMING_SNAKE_CASE
const API_BASE_URL = 'https://api.example.com'
const MAX_RETRY_ATTEMPTS = 3
const DEFAULT_PAGE_SIZE = 20

// ✅ 类型和接口：PascalCase
interface UserProfile {
  id: string
  name: string
  email: string
}

type ApiResponse<T> = {
  data: T
  status: number
}

class UserService {
  private apiClient: ApiClient
}

// ✅ 枚举：PascalCase
enum UserRole {
  ADMIN = 'admin',
  USER = 'user',
  GUEST = 'guest'
}

// ❌ 错误示例
const user_name = 'john'        // snake_case变量
const IsAuthenticated = true    // PascalCase变量
function get_user_data() { }    // snake_case函数
const apiBaseUrl = 'url'        // camelCase常量
```

#### Vue特殊命名
```vue
<template>
  <!-- ✅ 事件名：kebab-case -->
  <button @click="handleUserLogin">登录</button>
  <input @input-change="handleInputChange" />
  
  <!-- ✅ Props：camelCase in script, kebab-case in template -->
  <UserCard :user-name="userName" :is-active="isActive" />
</template>

<script setup lang="ts">
// ✅ Props定义：camelCase
interface Props {
  userName: string
  isActive: boolean
  maxLength?: number
}

// ✅ Emits定义：kebab-case
interface Emits {
  'user-login': [user: User]
  'status-change': [status: boolean]
  'input-change': [value: string]
}

// ✅ Composables：use开头 + camelCase
function useUserAuth() { }
function useApiClient() { }
function useLocalStorage() { }

// ✅ 计算属性：camelCase
const fullName = computed(() => `${firstName} ${lastName}`)
const isValidEmail = computed(() => /\S+@\S+\.\S+/.test(email.value))
</script>
```

### 🎨 CSS类名命名规范

#### BEM命名方法论
```scss
/* ✅ 正确：BEM格式 */
.user-card { }                    // Block
.user-card__avatar { }            // Element
.user-card__name { }              // Element
.user-card--featured { }          // Modifier
.user-card__avatar--large { }     // Element + Modifier

.navigation-menu { }
.navigation-menu__item { }
.navigation-menu__link { }
.navigation-menu__item--active { }

/* ❌ 错误示例 */
.userCard { }                     // camelCase
.user_card { }                    // snake_case
.UserCard { }                     // PascalCase
.user-card-avatar { }             // 多层级用-连接
```

#### TailwindCSS类名组织
```vue
<template>
  <!-- ✅ 正确：按功能分组的类名 -->
  <div class="
    flex items-center justify-between
    w-full max-w-md mx-auto
    p-6 mb-4
    text-lg font-semibold text-gray-900
    bg-white border border-gray-200 rounded-lg
    shadow-md hover:shadow-lg
    transition-shadow duration-200
  ">
    用户卡片
  </div>
  
  <!-- ❌ 错误：混乱的类名顺序 -->
  <div class="text-lg shadow-md bg-white mx-auto border-gray-200 p-6 transition-shadow flex w-full font-semibold">
    用户卡片
  </div>
</template>
```

### 📋 命名规范检查清单

#### 组件相关
- [ ] Vue组件使用PascalCase命名
- [ ] 组件文件名与组件名一致
- [ ] 组件实例在模板中使用PascalCase
- [ ] Props在script中使用camelCase，模板中使用kebab-case
- [ ] 事件名使用kebab-case

#### 文件系统
- [ ] 目录名使用kebab-case
- [ ] 非Vue文件使用kebab-case
- [ ] 避免缩写和简写
- [ ] 使用描述性名称

#### 代码变量
- [ ] 变量和函数使用camelCase
- [ ] 常量使用SCREAMING_SNAKE_CASE
- [ ] 类型和接口使用PascalCase
- [ ] Composables以use开头

#### 样式相关
- [ ] CSS类名遵循BEM命名
- [ ] TailwindCSS类名按功能分组
- [ ] 避免使用缩写类名
- [ ] 保持命名语义化

---

## 3. ESLint 9 配置规范 ⚙️

### 🚀 现代化配置

```javascript
// eslint.config.js
import pluginVue from "eslint-plugin-vue"
import { defineConfigWithVueTs, vueTsConfigs } from "@vue/eslint-config-typescript"
import skipFormatting from "@vue/eslint-config-prettier/skip-formatting"

export default defineConfigWithVueTs(
  // 文件匹配
  {
    name: "app/files-to-lint",
    files: ["**/*.{ts,mts,tsx,vue}"],
  },
  
  // 忽略文件
  {
    name: "app/files-to-ignore", 
    ignores: ["**/dist/**", "**/coverage/**"],
  },

  // Vue基础配置
  pluginVue.configs["flat/essential"],
  
  // TypeScript配置
  vueTsConfigs.recommended,
  
  // Prettier集成
  skipFormatting
)
```

### ⚡ 性能优化策略

```json
{
  "scripts": {
    "lint:oxlint": "oxlint . --fix -D correctness --ignore-path .gitignore",
    "lint:eslint": "eslint . --fix",
    "lint": "run-s lint:*"
  }
}
```

**性能提升**: Oxlint(Rust) + ESLint组合，检查速度提升10-100倍

### 📋 核心规则

```javascript
{
  // Vue组件规则
  'vue/component-definition-name-casing': ['error', 'PascalCase'],
  'vue/component-tags-order': ['error', {
    'order': ['template', 'script', 'style']
  }],
  'vue/multi-word-component-names': 'error',
  
  // TypeScript规则
  '@typescript-eslint/no-explicit-any': 'error',
  '@typescript-eslint/prefer-nullish-coalescing': 'error',
  '@typescript-eslint/no-unused-vars': ['error', {
    'argsIgnorePattern': '^_'
  }],
  
  // 代码质量
  'prefer-const': 'error',
  'no-var': 'error',
  'object-shorthand': 'error'
}
```

---

## 3. Pinia 状态管理 🗃️

### 🏗️ Store标准结构

```typescript
// stores/user.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { User, CreateUserData } from '@/types/user'

export const useUserStore = defineStore('user', () => {
  // ===== State =====
  const users = ref<User[]>([])
  const currentUser = ref<User | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)

  // ===== Getters =====
  const totalUsers = computed(() => users.value.length)
  const activeUsers = computed(() => 
    users.value.filter(user => user.isActive)
  )
  const isLoggedIn = computed(() => !!currentUser.value)

  // ===== Actions =====
  const fetchUsers = async () => {
    try {
      loading.value = true
      error.value = null
      
      const response = await userApi.getUsers()
      users.value = response.data
    } catch (err) {
      error.value = err instanceof Error ? err.message : '获取用户失败'
      throw err
    } finally {
      loading.value = false
    }
  }

  const createUser = async (userData: CreateUserData) => {
    try {
      loading.value = true
      const response = await userApi.createUser(userData)
      users.value.unshift(response.data)
      return response.data
    } catch (err) {
      error.value = '创建用户失败'
      throw err
    } finally {
      loading.value = false
    }
  }

  const clearError = () => {
    error.value = null
  }

  return {
    // State
    users, currentUser, loading, error,
    // Getters
    totalUsers, activeUsers, isLoggedIn,
    // Actions
    fetchUsers, createUser, clearError
  }
})
```

### 📦 模块化组织

```typescript
// stores/index.ts
export { useUserStore } from './modules/user'
export { useProductStore } from './modules/product'
export { useCartStore } from './modules/cart'

// stores/composables/useAuth.ts
export const useAuth = () => {
  const userStore = useUserStore()
  
  const login = async (credentials: LoginData) => {
    await userStore.login(credentials)
    // 其他登录后逻辑
  }
  
  return {
    login,
    logout: userStore.logout,
    user: userStore.currentUser,
    isLoggedIn: userStore.isLoggedIn
  }
}
```

### 🔑 最佳实践

- **Composition API风格**: 使用函数式定义
- **类型安全**: 完整TypeScript类型定义
- **错误处理**: 统一异步操作错误处理模式
- **状态持久化**: 合理使用localStorage同步

---

## 4. TailwindCSS 样式规范 🎨

### 🎯 组件样式示例

```vue
<template>
  <div class="user-card bg-white rounded-lg shadow-md p-6 hover:shadow-lg transition-shadow duration-200">
    <!-- 头像区域 -->
    <div class="flex items-center space-x-4 mb-4">
      <img 
        :src="user.avatar" 
        :alt="user.name"
        class="w-12 h-12 rounded-full object-cover"
      >
      <div class="flex-1">
        <h3 class="text-lg font-semibold text-gray-900">{{ user.name }}</h3>
        <p class="text-sm text-gray-600">{{ user.title }}</p>
      </div>
    </div>
    
    <!-- 状态标签 -->
    <div class="flex flex-wrap gap-2 mb-4">
      <span 
        :class="[
          'px-2 py-1 text-xs font-medium rounded-full',
          user.isActive 
            ? 'bg-green-100 text-green-800' 
            : 'bg-gray-100 text-gray-800'
        ]"
      >
        {{ user.isActive ? '在线' : '离线' }}
      </span>
    </div>
    
    <!-- 操作按钮 -->
    <div class="flex space-x-3">
      <button class="flex-1 px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
        发消息
      </button>
      <button class="px-4 py-2 border border-gray-300 text-gray-700 text-sm font-medium rounded-md hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors">
        查看详情
      </button>
    </div>
  </div>
</template>

<style scoped>
/* 仅用于Tailwind无法实现的复杂样式 */
.user-card {
  /* 自定义动画 */
  animation: fadeInUp 0.3s ease-out;
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>
```

### ⚙️ 配置优化

```css
/* src/styles/tailwind.css */
@import "tailwindcss";

/* TailwindCSS 4.x CSS-first配置 */
@theme {
  /* 颜色系统 */
  --color-primary-50: #eff6ff;
  --color-primary-500: #3b82f6;
  --color-primary-900: #1e3a8a;
  
  --color-secondary-50: #f9fafb;
  --color-secondary-500: #6b7280;
  --color-secondary-900: #111827;
  
  /* 字体系统 */
  --font-family-sans: Inter, system-ui, sans-serif;
  
  /* 间距系统 */
  --spacing-18: 4.5rem;
  --spacing-88: 22rem;
}

/* 插件功能 */
@plugin "@tailwindcss/forms";
@plugin "@tailwindcss/typography";
@plugin "@tailwindcss/aspect-ratio";
```

### 📐 设计系统规范

- **响应式优先**: Mobile-first设计策略
- **组件抽象**: 复杂样式组件化封装
- **主题一致**: 统一色彩和间距系统
- **性能优化**: 生产环境自动清理未使用样式

---

## 5. Vue 3 新特性应用 ⚡

### 🎪 Composition API

```vue
<template>
  <div class="user-dashboard">
    <SearchBox v-model="searchQuery" @search="handleSearch" />
    
    <div v-if="loading" class="loading">加载中...</div>
    
    <UserList 
      v-else
      :users="filteredUsers"
      @user-select="handleUserSelect"
    />
    
    <Pagination 
      :current="currentPage"
      :total="totalPages"
      @change="handlePageChange"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useUserStore } from '@/stores/modules/user'
import { useDebounce } from '@/composables/useDebounce'
import type { User } from '@/types/user'

// Store
const userStore = useUserStore()

// 响应式数据
const searchQuery = ref('')
const currentPage = ref(1)
const pageSize = ref(10)

// 防抖搜索
const debouncedQuery = useDebounce(searchQuery, 300)

// 计算属性
const loading = computed(() => userStore.loading)
const allUsers = computed(() => userStore.users)

const filteredUsers = computed(() => {
  let users = allUsers.value
  
  if (debouncedQuery.value) {
    users = users.filter(user => 
      user.name.toLowerCase().includes(debouncedQuery.value.toLowerCase())
    )
  }
  
  const start = (currentPage.value - 1) * pageSize.value
  return users.slice(start, start + pageSize.value)
})

const totalPages = computed(() => 
  Math.ceil(allUsers.value.length / pageSize.value)
)

// 方法
const handleSearch = (query: string) => {
  searchQuery.value = query
  currentPage.value = 1
}

const handleUserSelect = (user: User) => {
  console.log('选中用户:', user)
}

const handlePageChange = (page: number) => {
  currentPage.value = page
}

// 生命周期
onMounted(async () => {
  await userStore.fetchUsers()
})

// 监听器
watch(debouncedQuery, () => {
  currentPage.value = 1
})
</script>
```

### 🔧 自定义组合函数

```typescript
// composables/useDebounce.ts
import { ref, watch, Ref } from 'vue'

export function useDebounce<T>(value: Ref<T>, delay: number): Ref<T> {
  const debouncedValue = ref<T>(value.value)
  
  watch(value, (newValue) => {
    const timer = setTimeout(() => {
      debouncedValue.value = newValue
    }, delay)
    
    return () => clearTimeout(timer)
  })
  
  return debouncedValue as Ref<T>
}

// composables/useAsyncData.ts
import { ref, readonly } from 'vue'

export function useAsyncData<T>(fetcher: () => Promise<T>) {
  const data = ref<T>()
  const loading = ref(false)
  const error = ref<Error | null>(null)
  
  const execute = async () => {
    try {
      loading.value = true
      error.value = null
      
      const result = await fetcher()
      data.value = result
      return result
    } catch (err) {
      error.value = err instanceof Error ? err : new Error('Unknown error')
      throw err
    } finally {
      loading.value = false
    }
  }
  
  return {
    data: readonly(data),
    loading: readonly(loading),
    error: readonly(error),
    execute
  }
}

// 使用示例
const { data: users, loading, execute: fetchUsers } = useAsyncData(() => 
  userApi.getUsers()
)
```

### 🚀 性能优化特性

```vue
<template>
  <!-- Teleport: 传送组件到指定位置 -->
  <Teleport to="#modal-container">
    <Modal v-if="showModal" @close="showModal = false">
      <UserForm />
    </Modal>
  </Teleport>
  
  <!-- Suspense: 异步组件加载 -->
  <Suspense>
    <template #default>
      <AsyncUserList />
    </template>
    <template #fallback>
      <div class="loading">加载用户列表中...</div>
    </template>
  </Suspense>
  
  <!-- Fragment: 多根节点 -->
  <header class="page-header">
    <h1>用户管理</h1>
  </header>
  <main class="page-content">
    <UserTable />
  </main>
  <footer class="page-footer">
    <Pagination />
  </footer>
</template>
```

---

## 🛠️ 开发工具配置

### 📦 Package.json 脚本

```json
{
  "scripts": {
    "dev": "vite",
    "build": "run-p type-check \"build-only {@}\" --",
    "preview": "vite preview",
    "type-check": "vue-tsc --build",
    "lint:oxlint": "oxlint . --fix -D correctness --ignore-path .gitignore",
    "lint:eslint": "eslint . --fix",
    "lint": "run-s lint:*",
    "format": "prettier --write src/"
  }
}
```

### ⚙️ VS Code 配置

```json
// .vscode/settings.json
{
  "eslint.useFlatConfig": true,
  "eslint.validate": ["javascript", "typescript", "vue"],
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": "explicit"
  },
  "typescript.preferences.includePackageJsonAutoImports": "auto",
  "vue.codeActions.enabled": true
}
```

### 🔧 Vite 配置

```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  },
  build: {
    target: 'es2015',
    rollupOptions: {
      output: {
        manualChunks: {
          vue: ['vue', 'vue-router', 'pinia'],
          vendor: ['axios', 'lodash-es']
        }
      }
    }
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
})
```

---

## 📊 实施路线图

### 🎯 阶段一：基础设施 (1-2周)
- [x] 配置ESLint 9 + Oxlint
- [x] 设置TypeScript严格模式
- [x] 建立项目结构标准
- [x] VS Code开发环境配置

### 🎯 阶段二：核心规范 (2-3周) 
- [x] Pinia状态管理模式
- [x] 组件开发规范
- [x] TailwindCSS设计系统
- [x] 代码review流程

### 🎯 阶段三：优化提升 (1-2周)
- [x] 性能监控集成
- [x] 自动化测试
- [x] 构建优化
- [x] 文档完善

---

## 🎓 团队培训计划

### 📚 培训内容
1. **TypeScript基础** (4小时)
   - 类型系统原理
   - Vue项目中的类型应用
   - 常见类型问题解决

2. **ESLint配置与使用** (2小时)
   - 扁平配置格式
   - 自定义规则编写
   - 与IDE集成

3. **Pinia状态管理** (3小时)
   - Composition API模式
   - Store设计模式
   - 实际项目应用

4. **现代CSS开发** (3小时)
   - TailwindCSS最佳实践
   - 响应式设计
   - 组件样式架构

### 📈 效果评估
- **代码质量**: ESLint错误数量下降80%
- **开发效率**: 功能开发速度提升30%
- **团队协作**: Code Review时间减少50%

---

## 💡 常见问题

**Q: TypeScript学习成本如何？**
A: 提供类型定义模板，渐进式学习，从基础类型开始。

**Q: ESLint规则太严格怎么办？**
A: 分阶段实施，先warning再error，团队共识后逐步严格。

**Q: TailwindCSS会让代码冗长吗？**
A: 合理组件抽象，使用@apply指令，建立设计系统复用。

**Q: 如何处理历史项目迁移？**
A: 新功能采用新规范，存量代码逐步重构，不强制一次性迁移。

---

**这套规范将帮助团队建立现代化、高效的Vue开发标准，提升整体开发质量和效率。**